// Code generated by github.com/stackworx-go/graphql, DO NOT EDIT.
package {{ .PackageName }}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

type Client struct {
	http.Client
	URL string
}

type request struct {
	Query         string                 `json:"query"`
	// OperationName string                 `json:"operationName"`
	Variables     interface{} `json:"variables"`
	Extensions    map[string]interface{} `json:"extensions"`
}

type {{ .ScalarFileUpload }} struct {
	File        io.Reader
	Filename    string
	ContentType string
}

func (u *{{ .ScalarFileUpload }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(nil)
}

type RequestOpts struct {
	Header http.Header
}

type typename struct {
	Typename string `json:"__typename"`
}

type GraphqlError struct {
	Errors []gqlerror.Error
}

func (e *GraphqlError) Error() string {
	return "Graphql Request Failed"
}

{{ range .InputStructs }}
	{{template "struct" . }}
{{ end }}

{{ range .Queries }}
	{{template "request" . }}
{{ end }}

func extractFiles(data interface{}, path []string, files map[string]*Upload) error {
	t := reflect.TypeOf(data)

	if t == nil {
		return nil
	}

	// Upload Found
	if upload, ok := data.(Upload); ok {
		files[strings.Join(path, ".")] = &upload
		return nil
	} else if upload, ok := data.(*Upload); ok {
		files[strings.Join(path, ".")] = upload
		return nil
	}

	switch t.Kind() {
	case reflect.Array:
		array := data.([]interface{})

		for i, e := range array {
			extractFiles(e, append(path, strconv.Itoa(i)), files)
		}
		break
	case reflect.Struct:
		t := reflect.TypeOf(data)
		v := reflect.ValueOf(data)

		for i := 0; i < v.NumField(); i++ {
			f := t.Field(i)

			// TODO: error if empty
			jsonName := strings.Split(f.Tag.Get("json"), ",")[0]

			extractFiles(v.Field(i).Interface(), append(path, jsonName), files)
		}
	case reflect.Interface:
		return fmt.Errorf("interface not yet implemented")
	}

	return nil
}

func (c *Client) buildMultiPartRequest(input interface{}, opts *RequestOpts, requestBody []byte) (*http.Request, error) {
	var b bytes.Buffer
	w := multipart.NewWriter(&b)

	operationsField, err := w.CreateFormField("operations")

	if err != nil {
		return nil, err
	}

	_, err = fmt.Fprint(operationsField, string(requestBody))

	if err != nil {
		return nil, err
	}

	files := make(map[string]*Upload)
	extractFiles(input, []string{"variables", "input"}, files)

	pathMap := make(map[int][]string)

	i := 0

	for key, file := range files {
		fw, err := w.CreateFormFile(strconv.Itoa(i), file.Filename);

		if err != nil {
			return nil, err
		}

		if _, err = io.Copy(fw, file.File); err != nil {
			return nil, err
		}

		pathMap[i] = []string{key}
		i++
	}

	pathMapBytes, err := json.Marshal(pathMap)

	if err != nil {
		return nil, err
	}

	mapField, err := w.CreateFormField("map")
	fmt.Fprint(mapField, string(pathMapBytes))

	w.Close()

	req, err := http.NewRequest("POST", c.URL, &b)

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", w.FormDataContentType())

	return req, nil
}