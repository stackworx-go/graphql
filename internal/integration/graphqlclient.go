// Code generated by github.com/stackworx-go/graphql-client, DO NOT EDIT.
package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

type Client struct {
	http.Client
	URL string
}

type request struct {
	Query string `json:"query"`
	// OperationName string                 `json:"operationName"`
	Variables  interface{}            `json:"variables"`
	Extensions map[string]interface{} `json:"extensions"`
}

type RequestOpts struct {
	Header http.Header
}

type typename struct {
	Typename string `json:"__typename"`
}

type GraphqlError struct {
	Errors []gqlerror.Error
}

func (e *GraphqlError) Error() string {
	return "Graphql Request Failed"
}

type CreateTodoInput struct {
	Text   string `json:"text"`
	UserId string `json:"userId"`
}

var CreateTodoMutation = `mutation CreateTodoMutation ($input: CreateTodoInput!) {
	createTodo(input: $input) {
		todo {
			id
			text
			done
			user {
				id
				name
			}
		}
	}
}
`

type CreateTodoMutationPayloadCreateTodoTodoUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type CreateTodoMutationPayloadCreateTodoTodo struct {
	Id   string                                      `json:"id"`
	Text string                                      `json:"text"`
	Done bool                                        `json:"done"`
	User CreateTodoMutationPayloadCreateTodoTodoUser `json:"user"`
}

type CreateTodoMutationPayloadCreateTodo struct {
	Todo CreateTodoMutationPayloadCreateTodoTodo `json:"todo"`
}

type CreateTodoMutationPayload struct {
	CreateTodo CreateTodoMutationPayloadCreateTodo `json:"createTodo"`
}

type responseCreateTodoMutation struct {
	Data   *CreateTodoMutationPayload `json:"data"`
	Errors []gqlerror.Error           `json:"errors"`
}

func (c *Client) CreateTodoMutation(input CreateTodoInput, opts *RequestOpts) (*CreateTodoMutationPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: CreateTodoMutation,
		Variables: map[string]interface{}{
			"input": input,
		},
	})

	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, body)
	}

	var payload responseCreateTodoMutation
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var NodeQuery = `query NodeQuery ($nodeId: ID!) {
	node(id: $nodeId) {
		id
		... on User {
			name
			__typename
		}
		... on Todo {
			text
			__typename
		}
	}
}
`

type NodeQueryPayloadNodeUserFragment struct {
	Name       string `json:"name"`
	__typename string
}

type NodeQueryPayloadNodeTodoFragment struct {
	Text       string `json:"text"`
	__typename string
}

type NodeQueryPayloadNode struct {
	Id           string `json:"id"`
	UserFragment *NodeQueryPayloadNodeUserFragment
	TodoFragment *NodeQueryPayloadNodeTodoFragment
}

func (f *NodeQueryPayloadNode) UnmarshalJSON(data []byte) error {
	var typename typename
	err := json.Unmarshal(data, &typename)

	if err != nil {
		return err
	}

	// Extract local Fields if any
	// Causes circular loop
	// Will need second struct
	// err = json.Unmarshal(data, &f)

	// f.__typename = typename.Typename

	switch typename.Typename {
	case "User":
		err = json.Unmarshal(data, &f.UserFragment)
		if err != nil {
			return err
		}
	case "Todo":
		err = json.Unmarshal(data, &f.TodoFragment)
		if err != nil {
			return err
		}
	default:
		panic(fmt.Errorf("unexpected object type: %s", typename.Typename))
	}

	return nil
}

type NodeQueryPayload struct {
	Node *NodeQueryPayloadNode `json:"node,omitempty"`
}

type responseNodeQuery struct {
	Data   *NodeQueryPayload `json:"data"`
	Errors []gqlerror.Error  `json:"errors"`
}

func (c *Client) NodeQuery(nodeId string, opts *RequestOpts) (*NodeQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: NodeQuery,
		Variables: map[string]interface{}{
			"nodeId": nodeId,
		},
	})

	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, body)
	}

	var payload responseNodeQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var TodosQuery = `query TodosQuery {
	todos {
		id
		text
		done
		user {
			id
			name
		}
	}
}
`

type TodosQueryPayloadTodosUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type TodosQueryPayloadTodos struct {
	Id   string                     `json:"id"`
	Text string                     `json:"text"`
	Done bool                       `json:"done"`
	User TodosQueryPayloadTodosUser `json:"user"`
}

type TodosQueryPayload struct {
	Todos []TodosQueryPayloadTodos `json:"todos"`
}

type responseTodosQuery struct {
	Data   *TodosQueryPayload `json:"data"`
	Errors []gqlerror.Error   `json:"errors"`
}

func (c *Client) TodosQuery(opts *RequestOpts) (*TodosQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: TodosQuery,
	})

	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, body)
	}

	var payload responseTodosQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var TodosWithVariablesQuery = `query TodosWithVariablesQuery ($userId: ID!) {
	todos(userId: $userId) {
		id
		text
		done
		user {
			id
			name
		}
	}
}
`

type TodosWithVariablesQueryPayloadTodosUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type TodosWithVariablesQueryPayloadTodos struct {
	Id   string                                  `json:"id"`
	Text string                                  `json:"text"`
	Done bool                                    `json:"done"`
	User TodosWithVariablesQueryPayloadTodosUser `json:"user"`
}

type TodosWithVariablesQueryPayload struct {
	Todos []TodosWithVariablesQueryPayloadTodos `json:"todos"`
}

type responseTodosWithVariablesQuery struct {
	Data   *TodosWithVariablesQueryPayload `json:"data"`
	Errors []gqlerror.Error                `json:"errors"`
}

func (c *Client) TodosWithVariablesQuery(userId string, opts *RequestOpts) (*TodosWithVariablesQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: TodosWithVariablesQuery,
		Variables: map[string]interface{}{
			"userId": userId,
		},
	})

	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, body)
	}

	var payload responseTodosWithVariablesQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}
