// Code generated by github.com/stackworx-go/graphql, DO NOT EDIT.
package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

type Client struct {
	http.Client
	URL string
}

type request struct {
	Query string `json:"query"`
	// OperationName string                 `json:"operationName"`
	Variables  interface{}            `json:"variables"`
	Extensions map[string]interface{} `json:"extensions"`
}

type Upload struct {
	File        io.Reader
	Filename    string
	ContentType string
}

func (u *Upload) MarshalJSON() ([]byte, error) {
	return json.Marshal(nil)
}

type RequestOpts struct {
	Header http.Header
}

type typename struct {
	Typename string `json:"__typename"`
}

type GraphqlError struct {
	Errors []gqlerror.Error
}

func (e *GraphqlError) Error() string {
	return "Graphql Request Failed"
}

type UploadFileInput struct {
	Id   string  `json:"id"`
	File *Upload `json:"file,omitempty"`
}

type CreateTodoInput struct {
	Text   string `json:"text"`
	UserId string `json:"userId"`
}

type UploadFile struct {
	Id   int    `json:"id"`
	File Upload `json:"file"`
}

var CreateTodoMutation = `mutation CreateTodoMutation ($input: CreateTodoInput!) {
	createTodo(input: $input) {
		todo {
			id
			text
			done
			user {
				id
				name
			}
		}
	}
}
`

type CreateTodoMutationPayloadCreateTodoTodoUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type CreateTodoMutationPayloadCreateTodoTodo struct {
	Id   string                                      `json:"id"`
	Text string                                      `json:"text"`
	Done bool                                        `json:"done"`
	User CreateTodoMutationPayloadCreateTodoTodoUser `json:"user"`
}

type CreateTodoMutationPayloadCreateTodo struct {
	Todo CreateTodoMutationPayloadCreateTodoTodo `json:"todo"`
}

type CreateTodoMutationPayload struct {
	CreateTodo CreateTodoMutationPayloadCreateTodo `json:"createTodo"`
}

type responseCreateTodoMutation struct {
	Data   *CreateTodoMutationPayload `json:"data"`
	Errors []gqlerror.Error           `json:"errors"`
}

func (c *Client) CreateTodoMutation(input CreateTodoInput, opts *RequestOpts) (*CreateTodoMutationPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: CreateTodoMutation,
		Variables: map[string]interface{}{
			"input": input,
		},
	})

	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, string(body))
	}

	var payload responseCreateTodoMutation
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var FileUploadMutation = `mutation FileUploadMutation ($input: UploadFileInput!) {
	uploadFile(input: $input) {
		file {
			name
		}
	}
}
`

type FileUploadMutationPayloadUploadFileFile struct {
	Name string `json:"name"`
}

type FileUploadMutationPayloadUploadFile struct {
	File FileUploadMutationPayloadUploadFileFile `json:"file"`
}

type FileUploadMutationPayload struct {
	UploadFile FileUploadMutationPayloadUploadFile `json:"uploadFile"`
}

type responseFileUploadMutation struct {
	Data   *FileUploadMutationPayload `json:"data"`
	Errors []gqlerror.Error           `json:"errors"`
}

func (c *Client) FileUploadMutation(input UploadFileInput, opts *RequestOpts) (*FileUploadMutationPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: FileUploadMutation,
		Variables: map[string]interface{}{
			"input": input,
		},
	})

	if err != nil {
		return nil, err
	}
	req, err := c.buildMultiPartRequest(input, opts, requestBody)

	if err != nil {
		return nil, err
	}

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, string(body))
	}

	var payload responseFileUploadMutation
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var NodeQuery = `query NodeQuery ($nodeId: ID!) {
	node(id: $nodeId) {
		id
		... on User {
			name
			__typename
		}
		... on Todo {
			text
			__typename
		}
	}
}
`

type NodeQueryPayloadNodeUserFragment struct {
	Name       string `json:"name"`
	__typename string
}

type NodeQueryPayloadNodeTodoFragment struct {
	Text       string `json:"text"`
	__typename string
}

type NodeQueryPayloadNode struct {
	Id           string `json:"id"`
	UserFragment *NodeQueryPayloadNodeUserFragment
	TodoFragment *NodeQueryPayloadNodeTodoFragment
}

func (f *NodeQueryPayloadNode) UnmarshalJSON(data []byte) error {
	var typename typename
	err := json.Unmarshal(data, &typename)

	if err != nil {
		return err
	}

	// Extract local Fields if any
	// Causes circular loop
	// Will need second struct
	// err = json.Unmarshal(data, &f)

	// f.__typename = typename.Typename

	switch typename.Typename {
	case "User":
		err = json.Unmarshal(data, &f.UserFragment)
		if err != nil {
			return err
		}
	case "Todo":
		err = json.Unmarshal(data, &f.TodoFragment)
		if err != nil {
			return err
		}
	default:
		panic(fmt.Errorf("unexpected object type: %s", typename.Typename))
	}

	return nil
}

type NodeQueryPayload struct {
	Node *NodeQueryPayloadNode `json:"node,omitempty"`
}

type responseNodeQuery struct {
	Data   *NodeQueryPayload `json:"data"`
	Errors []gqlerror.Error  `json:"errors"`
}

func (c *Client) NodeQuery(nodeId string, opts *RequestOpts) (*NodeQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: NodeQuery,
		Variables: map[string]interface{}{
			"nodeId": nodeId,
		},
	})

	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, string(body))
	}

	var payload responseNodeQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var TodosQuery = `query TodosQuery {
	todos {
		id
		text
		done
		user {
			id
			name
		}
	}
}
`

type TodosQueryPayloadTodosUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type TodosQueryPayloadTodos struct {
	Id   string                     `json:"id"`
	Text string                     `json:"text"`
	Done bool                       `json:"done"`
	User TodosQueryPayloadTodosUser `json:"user"`
}

type TodosQueryPayload struct {
	Todos []TodosQueryPayloadTodos `json:"todos"`
}

type responseTodosQuery struct {
	Data   *TodosQueryPayload `json:"data"`
	Errors []gqlerror.Error   `json:"errors"`
}

func (c *Client) TodosQuery(opts *RequestOpts) (*TodosQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: TodosQuery,
	})

	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, string(body))
	}

	var payload responseTodosQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

var TodosWithVariablesQuery = `query TodosWithVariablesQuery ($userId: ID!) {
	todos(userId: $userId) {
		id
		text
		done
		user {
			id
			name
		}
	}
}
`

type TodosWithVariablesQueryPayloadTodosUser struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type TodosWithVariablesQueryPayloadTodos struct {
	Id   string                                  `json:"id"`
	Text string                                  `json:"text"`
	Done bool                                    `json:"done"`
	User TodosWithVariablesQueryPayloadTodosUser `json:"user"`
}

type TodosWithVariablesQueryPayload struct {
	Todos []TodosWithVariablesQueryPayloadTodos `json:"todos"`
}

type responseTodosWithVariablesQuery struct {
	Data   *TodosWithVariablesQueryPayload `json:"data"`
	Errors []gqlerror.Error                `json:"errors"`
}

func (c *Client) TodosWithVariablesQuery(userId string, opts *RequestOpts) (*TodosWithVariablesQueryPayload, error) {
	requestBody, err := json.Marshal(request{
		Query: TodosWithVariablesQuery,
		Variables: map[string]interface{}{
			"userId": userId,
		},
	})

	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", c.URL, bytes.NewReader(requestBody))

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := c.Do(req)

	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("Request Failed with status code: %d, body: %v", resp.StatusCode, string(body))
	}

	var payload responseTodosWithVariablesQuery
	err = json.Unmarshal(body, &payload)

	if err != nil {
		return nil, err
	}

	if len(payload.Errors) > 0 {
		return nil, &GraphqlError{Errors: payload.Errors}
	}

	return payload.Data, nil
}

func extractFiles(data interface{}, path []string, files map[string]*Upload) error {
	t := reflect.TypeOf(data)

	if t == nil {
		return nil
	}

	// Upload Found
	if upload, ok := data.(Upload); ok {
		files[strings.Join(path, ".")] = &upload
		return nil
	} else if upload, ok := data.(*Upload); ok {
		files[strings.Join(path, ".")] = upload
		return nil
	}

	switch t.Kind() {
	case reflect.Array:
		array := data.([]interface{})

		for i, e := range array {
			extractFiles(e, append(path, strconv.Itoa(i)), files)
		}
		break
	case reflect.Struct:
		t := reflect.TypeOf(data)
		v := reflect.ValueOf(data)

		for i := 0; i < v.NumField(); i++ {
			f := t.Field(i)

			// TODO: error if empty
			jsonName := strings.Split(f.Tag.Get("json"), ",")[0]

			extractFiles(v.Field(i).Interface(), append(path, jsonName), files)
		}
	case reflect.Interface:
		return fmt.Errorf("interface not yet implemented")
	}

	return nil
}

func (c *Client) buildMultiPartRequest(input interface{}, opts *RequestOpts, requestBody []byte) (*http.Request, error) {
	var b bytes.Buffer
	w := multipart.NewWriter(&b)

	operationsField, err := w.CreateFormField("operations")

	if err != nil {
		return nil, err
	}

	_, err = fmt.Fprint(operationsField, string(requestBody))

	if err != nil {
		return nil, err
	}

	files := make(map[string]*Upload)
	extractFiles(input, []string{"variables", "input"}, files)

	pathMap := make(map[int][]string)

	i := 0

	for key, file := range files {
		fw, err := w.CreateFormFile(strconv.Itoa(i), file.Filename)

		if err != nil {
			return nil, err
		}

		if _, err = io.Copy(fw, file.File); err != nil {
			return nil, err
		}

		pathMap[i] = []string{key}
		i++
	}

	pathMapBytes, err := json.Marshal(pathMap)

	if err != nil {
		return nil, err
	}

	mapField, err := w.CreateFormField("map")
	fmt.Fprint(mapField, string(pathMapBytes))

	w.Close()

	req, err := http.NewRequest("POST", c.URL, &b)

	if err != nil {
		return nil, err
	}

	if opts != nil {
		req.Header = opts.Header
	}

	req.Header.Set("Content-Type", w.FormDataContentType())

	return req, nil
}
